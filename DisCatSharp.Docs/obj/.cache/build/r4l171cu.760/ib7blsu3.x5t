<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

    <head>
      <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>DisCatSharp Events | DisCatSharp Docs </title>
      <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
      <meta name="generator" content="docfx 2.60.0.0">
  
    <meta name="og:type" content="website">
    <meta name="og:image" content="https://cdn.aitsys.dev/file/data/kmjpa6f64me66dsm7dz3/PHID-FILE-degpfzd7nbw2q5yko5j7/logobig.png">
    <meta name="og:image:alt" content="DisCatSharp Logo">
    <meta name="og:image:type" content="image/png">
    <meta name="og:site_name" content="DisCatSharp Documentation">
    <link rel="apple-touch-icon" sizes="57x57" href="../../apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="../../apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="../../apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="../../apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="../../apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="../../apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="../../apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="../../apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="../../apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="../../android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="../../favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png">
    <link rel="manifest" href="/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="../../ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
      <link rel="shortcut icon" href="../../favicon.ico">
      <script defer="" src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "de6c22ce0b3e4c17bb78c8c31b4e695b"}'></script>
      <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/night-owl.min.css">
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" integrity="sha384-EvBWSlnoFgZlXJvpzS+MAUEjvN7+gcCwH+qh7GRFOGgZO0PuwOFro7qPOJnLfe7l" crossorigin="anonymous">
      <link rel="stylesheet" href="../../src/styles/config.css">
      <link rel="stylesheet" href="../../src/styles/discord.css">
      <link rel="stylesheet" href="../../src/styles/dcs.css">
      <link rel="stylesheet" href="../../src/styles/main.css">
      <link rel="stylesheet" href="../../src/styles/colors.css">
      <link rel="stylesheet" href="../../src/styles/highlight/github-dark.min.css">
      <meta property="docfx:navrel" content="../../toc.html">
      <meta property="docfx:tocrel" content="../toc.html">
  
  <meta property="docfx:rel" content="../../">
  <meta property="docfx:newtab" content="true">
    </head>

    <body>
        <div class="top-navbar">
            <a class="burger-icon" onclick="toggleMenu()">
                <svg name="Hamburger" style="vertical-align: middle;" width="34" height="34" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M20 6H4V9H20V6ZM4 10.999H20V13.999H4V10.999ZM4 15.999H20V18.999H4V15.999Z"></path></svg>
            </a>


            <a class="navbar-brand" href="../../index.html">
              <img id="logo" class="svg" src="../../logo.png" alt="DisCatSharp">
            </a>
        </div>

        <div class="body-content">
            <div id="blackout" class="blackout" onclick="toggleMenu()"></div>

            <nav id="sidebar" role="navigation">
                <div class="sidebar">

                    <div>
                      <div class="mobile-hide">

                        <a class="navbar-brand" href="../../index.html">
                          <img id="logo" class="svg" src="../../logo.png" alt="DisCatSharp">
                        </a>
                      </div>

                      <div class="sidesearch">
                        <form id="search" role="search" class="search">
                            <i class="bi bi-search search-icon"></i>
                            <input type="text" id="search-query" placeholder="Search" autocomplete="off">
                        </form>
                      </div>

                      <div id="navbar">
                      </div>
                    </div>
                    <div class="sidebar-item-separator"></div>

                        <div id="sidetoggle">
                          <div id="sidetoc"></div>
                        </div>
                </div>
                <div class="footer">
  <strong>Made with â™¥ by AITSYS</strong>
  
                </div>
            </nav>

            <main class="main-panel">

                <div id="search-results" style="display: none;">
                  <h1 class="search-list">Search Results for <span></span></h1>
                  <div class="sr-items">
                    <p class="lsearch"><i class="bi bi-hourglass-split index-loading"></i></p>
                  </div>
                  <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
                </div>

                <div role="main" class="hide-when-search">

                        <div class="subnav navbar navbar-default">
                          <div class="container hide-when-search" id="breadcrumb">
                            <ul class="breadcrumb">
                              <li></li>
                            </ul>
                          </div>
                        </div>

      <div id="sidetoggle">
        <div id="sidetoc"></div>
      </div>
						<div class="article row grid-right">

                    <article class="content wrap" id="_content" data-uid="beyond_basics_events">
<h1 id="consuming-events" sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="6" sourceendlinenumber="6">Consuming Events</h1>

<p sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="7" sourceendlinenumber="8">DisCatSharp makes use of <em>asynchronous events</em> which will execute each handler asynchronously in sequential order. 
This event system will require event handlers have a <code>Task</code> return type and take two parameters.</p>
<p sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="10" sourceendlinenumber="11">The first parameter will contain an instance of the object which fired the event.<br>
The second parameter will contain an arguments object for the specific event you&#39;re handling.</p>
<p sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="13" sourceendlinenumber="13">Below is a snippet demonstrating this with a lambda expression.</p>
<pre sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="14" sourceendlinenumber="31"><code class="lang-cs">private async Task MainAsync()
{
    var discord = new DiscordClient();

    discord.MessageCreated += async (s, e) =&gt;
    {
        if (e.Message.Content.ToLower().Contains(&quot;spiderman&quot;)) 
            await e.Message.RespondAsync(&quot;I want pictures of Spiderman!&quot;);
    };

    discord.GuildMemberAdded += (s, e) =&gt;
    {
        // Non asynchronous code here.
        return Task.CompletedTask;
    };
}
</code></pre><p sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="33" sourceendlinenumber="33">Alternatively, you can create a new method to consume an event.</p>
<pre sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="34" sourceendlinenumber="54"><code class="lang-cs">private async Task MainAsync()
{
    var discord = new DiscordClient();

    discord.MessageCreated += MessageCreatedHandler;
    discord.GuildMemberAdded += MemberAddedHandler;
}

private async Task MessageCreatedHandler(DiscordClient s, MessageCreateEventArgs e)
{
    if (e.Guild?.Id == 379378609942560770 &amp;&amp; e.Author.Id == 168548441939509248)
        await e.Message.DeleteAsync();
}

private Task MemberAddedHandler(DiscordClient s, GuildMemberAddEventArgs e)
{
    // Non asynchronous code here.
    return Task.CompletedTask;
}
</code></pre><h1 id="using-automatic-event-registration" sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="56" sourceendlinenumber="56">Using automatic event registration</h1>
<p sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="57" sourceendlinenumber="57">Instead of having to manually register each event, the attributes <code>Event</code> and <code>EventHandler</code> can be utilized to semi-automatically register events in a multitude of ways.</p>
<p sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="59" sourceendlinenumber="59">By attributing all classes that constitute event handlers with <code>EventHandler</code> and all methods within those classes that are intended to handle events with <code>Event</code> you can register all of those events with a single call to <code>DiscordClient.RegisterEventHandlers(Assembly)</code></p>
<pre sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="61" sourceendlinenumber="70"><code class="lang-cs">[EventHandler]
public class MyEventHandler {
    [Event]
    private async Task MessageCreated(DiscordClient s, MessageCreateEventArgs e) { /* ... */ }

    [Event(DiscordEvent.MessageCreated)] // You can specify the event name in the attribute, instead of via the method name!
    public static async Task MySecondaryHandler(DiscordClient s, MessageCreateEventArgs e) { /* ... */ }
}
</code></pre><pre sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="72" sourceendlinenumber="77"><code class="lang-cs">private async Task MainAsync() {
    var discord = new DiscordClient();
    discord.RegisterEventHandlers(Assembly.GetExecutingAssembly());
}
</code></pre><p sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="79" sourceendlinenumber="79">If an event handler class is not <code>abstract</code> (which also means not <code>static</code>) it will be instantiated, optionally with the help of an <code>IServiceProvider</code>, if one has been provided to the <code>DiscordConfig</code>. The inability to instantiate an event handler type constitutes an error.</p>
<pre sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="81" sourceendlinenumber="93"><code class="lang-cs">public class SomeClass { }

[EventHandler]
public class MyOtherEventHandler {
    private SomeClass some;

    public MyOtherEventHandler(SomeClass some) { this.some = some; }

    [Event]
    public async Task MessageCreated(DiscordClient s, MessageCreateEventArgs e) { /* do something with some */ }
}
</code></pre><p sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="95" sourceendlinenumber="95">In the above example an instance of <code>SomeClass</code> will need to be provided to the <code>DiscordContext</code>&#39;s <code>IServiceProvider</code>, read the next chapter to see how to accomplish that!</p>
<p sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="97" sourceendlinenumber="97">You can also register individual types, and even individual objects as event handlers using the overloaded method <code>DiscordClient.RegisterEventHandler</code>. In both of those cases the attribute <code>EventHandler</code> is not required.</p>
<p sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="99" sourceendlinenumber="101">When registering an object as a handler, by default the type&#39;s static methods will <em>not</em> be considered as event handling methods.
This allows for registering multiple instances of the same type without registering their static event handling methods multiple times.
To register the static methods exclusively, use <code>DiscordClient.RegisterStaticEventHandler</code> with the type in question.</p>
<h1 id="dependency-injection" sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="103" sourceendlinenumber="103">Dependency Injection</h1>
<p sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="104" sourceendlinenumber="105">Often, you need a way to get data in and out of your event handlers.
Although you <em>could</em> use <code>static</code> fields to accomplish this, the preferred solution would be <em>dependency injection</em>.</p>
<p sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="107" sourceendlinenumber="108">First, you need to register the services that you can use in the event handlers in the future.
You can do this in DiscordConfiguration:</p>
<pre sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="109" sourceendlinenumber="119"><code class="lang-cs">var config = new DiscordConfiguration()
{
    Token = &quot;Token here&quot;,
    TokenType = TokenType.Bot,
    ServiceProvider = new ServiceCollection()
        .AddScoped&lt;YourService&gt;()
        .AddSingleton&lt;YourSecondService&gt;()
        .BuildServiceProvider()
};
</code></pre><p sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="120" sourceendlinenumber="120">In this case, we have registered two services: <code>YourService</code> as Scoped and<code>YourSecondService</code> as Singleton.</p>
<p sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="122" sourceendlinenumber="122">Now you can use them in your event handlers.</p>
<pre sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="123" sourceendlinenumber="129"><code class="lang-cs">private async Task MessageCreatedHandler(DiscordClient s, MessageCreateEventArgs e)
{
    var service = e.ServiceProvider.GetRequiredService&lt;YourService&gt;();
    var secondService = e.ServiceProvider.GetRequiredService&lt;YourSecondService&gt;();
}
</code></pre><h3 id="services" sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="131" sourceendlinenumber="131">Services</h3>
<table sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="132" sourceendlinenumber="136">
<thead>
<tr>
<th style="text-align:center">Lifespan</th>
<th style="text-align:left">Instantiated</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Singleton</td>
<td style="text-align:left">One time when added to the collection.</td>
</tr>
<tr>
<td style="text-align:center">Scoped</td>
<td style="text-align:left">Once for each event handler.</td>
</tr>
<tr>
<td style="text-align:center">Transient</td>
<td style="text-align:left">Every request to the ServiceProvider.</td>
</tr>
</tbody>
</table>
<h1 id="avoiding-deadlocks" sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="138" sourceendlinenumber="138">Avoiding Deadlocks</h1>
<p sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="139" sourceendlinenumber="140">Despite the fact that your event handlers are executed asynchronously, they are also executed one at a time on the gateway thread for consistency. 
This means that each handler must complete its execution before others can be dispatched. </p>
<p sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="142" sourceendlinenumber="144">Because of this, executing code in your event handlers that runs for an extended period of time may inadvertently 
create brief unresponsiveness or, even worse, cause a <a href="https://en.wikipedia.org/wiki/Deadlock" data-raw-source="[deadlock](https://en.wikipedia.org/wiki/Deadlock)" sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="143" sourceendlinenumber="143">deadlock</a>.
To prevent such issues, any event handler that has the potential to take more than 2 seconds to execute should have its logic offloaded to a <code>Task.Run</code>.</p>
<pre sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="146" sourceendlinenumber="162"><code class="lang-cs">discord.MessageCreated += (s, e) =&gt;
{
    _ = Task.Run(async () =&gt;
    {
        // Pretend this takes many, many seconds to execute.
        var response = await QuerySlowWebServiceAsync(e.Message.Content);

        if (response.Status == HttpStatusCode.OK)
        {
            await e.Guild?.BanMemberAsync((DiscordMember)e.Author);
        }
    });

    return Task.CompletedTask;
};
</code></pre><p sourcefile="articles/beyond_basics/events.md" sourcestartlinenumber="163" sourceendlinenumber="163">Doing this will allow the handler to complete its execution quicker, which will in turn allow other handlers to be executed and prevent the gateway thread from being blocked.</p>
</article>
                </div>

                <div class="copyright-footer">
                    <span>&#169; Aiko IT Systems. All rights reserved.</span>
                </div>
            </div></main>
        </div>


        <script src="https://code.jquery.com/jquery-3.5.1.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
        <script type="text/javascript" src="../../src/scripts/docfx.vendor.js"></script>
        <script type="text/javascript" src="../../src/scripts/docfx.js"></script>
        <script type="text/javascript" src="../../src/scripts/url.min.js"></script>
        <script type="text/javascript" src="../../src/scripts/highlight/highlight.min.js"></script>
        <script>hljs.highlightAll();</script>
        <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js"></script>
        <script type="text/javascript" src="../../src/scripts/jquery.twbsPagination.js"></script>
        <script type="text/javascript" src="../../src/scripts/dcs.js"></script>
        <script type="text/javascript" src="../../src/scripts/lunr.js"></script>
    </body>
</html>
